// This file contains the logic for creating different types of visualizations.

// A global variable to hold the fetched data so we don't refetch it on every slide.
let sensorData = null;
let attentionData = null; // FIX: Added the missing global variable declaration.
let forecastData = null; // NEW: To hold forecast data
let failureData = null; // NEW: To hold failure simulation data

// --- Data Fetching ---
async function getSensorData() {
  if (sensorData) {
    return sensorData;
  }
  try {
    const response = await fetch("js/custom/sensor_data.json");
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    sensorData = await response.json();
    return sensorData;
  } catch (error) {
    console.error("Failed to fetch sensor data:", error);
    return null;
  }
}

async function getAttentionData() {
  if (attentionData) return attentionData;
  try {
    const response = await fetch("js/custom/attention_weights.json");
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    attentionData = await response.json();
    return attentionData;
  } catch (error) {
    console.error("Failed to fetch attention data:", error);
    return null;
  }
}

// UPDATED: This function now fetches the new stitched failure data file.
async function getFailureData() {
  if (failureData) return failureData;
  try {
    // This is the new filename generated by the updated Python script.
    const response = await fetch("js/custom/simulated_failure.json");
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    failureData = await response.json();
    return failureData;
  } catch (error) {
    console.error("Failed to fetch stitched failure simulation data:", error);
    return null;
  }
}

// NEW: Function to fetch forecast data
async function getForecastData() {
  if (forecastData) return forecastData;
  try {
    const response = await fetch("js/custom/forecast_timeseries.json");
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    forecastData = await response.json();
    return forecastData;
  } catch (error) {
    console.error("Failed to fetch forecast data:", error);
    return null;
  }
}

// --- Visualization Creation Functions ---

function createSensorMap(containerId, data) {
  const mapContainer = document.getElementById(containerId);
  if (!mapContainer || mapContainer.getAttribute("data-initialized")) return;

  if (mapContainer._leaflet_id) {
    mapContainer._leaflet_id = null;
  }

  const { sensorNodes, boundingBox } = data;
  const mapCenter = [54.983265, -1.58083];
  const map = L.map(containerId).setView(mapCenter, 15);

  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
    {
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: "abcd",
      maxZoom: 20,
    }
  ).addTo(map);

  sensorNodes.forEach((node) => {
    if (!node.pos) return;
    const markerColor = node.type === "sensor" ? "#00a8ff" : "#e84118";
    L.circleMarker(node.pos, {
      radius: 8,
      fillColor: markerColor,
      color: "#fff",
      weight: 1,
      opacity: 1,
      fillOpacity: 0.8,
    })
      .addTo(map)
      .bindPopup(
        `<strong>Name:</strong> ${node.name}<br><strong>Type:</strong> ${node.type}`
      );
  });

  const lats = boundingBox.map((p) => p[1]);
  const lngs = boundingBox.map((p) => p[0]);
  L.rectangle(
    [
      [Math.min(...lats), Math.min(...lngs)],
      [Math.max(...lats), Math.max(...lngs)],
    ],
    {
      color: "#ff7800",
      weight: 2,
      fillOpacity: 0.1,
    }
  ).addTo(map);

  mapContainer.setAttribute("data-initialized", "true");
}

function createBarChart(containerId, data) {
  const canvas = document.getElementById(containerId);
  if (!canvas || canvas.getAttribute("data-initialized")) return;

  const { sensorCounts } = data;
  const chartLabels = Object.keys(sensorCounts);
  const percentages = Object.values(sensorCounts);

  const lerpColor = (a, b, amount) => {
    const ar = a >> 16,
      ag = (a >> 8) & 0xff,
      ab = a & 0xff,
      br = b >> 16,
      bg = (b >> 8) & 0xff,
      bb = b & 0xff,
      rr = ar + amount * (br - ar),
      rg = ag + amount * (bg - ag),
      rb = ab + amount * (bb - ab);
    return `#${(((1 << 24) + (rr << 16) + (rg << 8) + rb) | 0)
      .toString(16)
      .slice(1)}`;
  };

  const minPercent = Math.min(...percentages);
  const maxPercent = Math.max(...percentages);
  const colorStart = 0x00a39b;
  const colorEnd = 0xda1a35;

  const backgroundColors = percentages.map((p) => {
    const amount =
      maxPercent - minPercent > 0
        ? (p - minPercent) / (maxPercent - minPercent)
        : 0.5;
    return lerpColor(colorEnd, colorStart, amount);
  });

  const ctx = canvas.getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: chartLabels,
      datasets: [
        {
          label: "Data Completeness (%)",
          data: percentages,
          backgroundColor: backgroundColors,
          borderColor: "rgba(255, 255, 255, 0.2)",
          borderWidth: 1,
        },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      indexAxis: "y",
      scales: {
        x: {
          beginAtZero: true,
          ticks: {
            color: "#FFFFFF",
            callback: function (value) {
              return value.toFixed(1) + "%";
            },
          },
          grid: {
            color: "rgba(255, 255, 255, 0.2)",
          },
        },
        y: {
          ticks: {
            color: "#FFFFFF",
          },
          grid: {
            display: false,
          },
        },
      },
      plugins: {
        legend: {
          display: false,
        },
        tooltip: {
          callbacks: {
            label: function (context) {
              let label = context.dataset.label || "";
              if (label) {
                label += ": ";
              }
              if (context.parsed.x !== null) {
                label += context.parsed.x.toFixed(2) + "%";
              }
              return label;
            },
          },
        },
      },
    },
  });
  canvas.setAttribute("data-initialized", "true");
}

function createFlowchart(containerId) {
  const container = document.getElementById(containerId);
  if (!container || container.getAttribute("data-initialized")) return;

  const flowchartDefinition = `
        graph TD
            subgraph Input Data
                direction LR
                A["Static Features<br>(Centrality, etc.)"]
                B["Dynamic Features<br>(P past values)"]
                C["Direction ID"]
            end
            subgraph Feature Engineering
                D["Direction Embedding"]
                E["Positional Embedding"]
            end
            subgraph Spatial Processing
                F["GATv2Conv Layer<br>Learns spatial relationships"]
            end
            subgraph Temporal Processing
                G(("Temporal<br>Self-Attention<br>Blocks"))
            end
            subgraph Prediction Head
                H["Output Layer<br>(Linear)"]
            end
            I["Final Prediction<br>(Q future values)"]
            C --> D;
            A & B & D --> J(Combine Features);
            J --> F;
            F --> K{Spatio-Temporal Features};
            E --> K;
            K --> G;
            G --> H;
            H --> I;
            classDef input fill:#2c3e50,stroke:#3498db,stroke-width:2px,color:#fff;
            classDef process fill:#16a085,stroke:#1abc9c,stroke-width:2px,color:#fff;
            classDef output fill:#8e44ad,stroke:#9b59b6,stroke-width:2px,color:#fff;
            class A,B,C input;
            class D,E,J,F,K process;
            class G process;
            class H,I output;
    `;

  mermaid.render(containerId + "-svg", flowchartDefinition).then(({ svg }) => {
    container.innerHTML = svg;
  });
  container.setAttribute("data-initialized", "true");
}

function createConnectedGraph(containerId, data) {
  const mapContainer = document.getElementById(containerId);
  if (!mapContainer || mapContainer.getAttribute("data-initialized")) return;
  if (mapContainer._leaflet_id) {
    mapContainer._leaflet_id = null;
  }

  const { sensorNodes } = data;
  const mapCenter = [54.983265, -1.58083];
  const map = L.map(containerId).setView(mapCenter, 15);

  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
    {
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: "abcd",
      maxZoom: 20,
    }
  ).addTo(map);

  if (sensorNodes && sensorNodes.length > 1) {
    for (let i = 0; i < sensorNodes.length; i++) {
      for (let j = i + 1; j < sensorNodes.length; j++) {
        const pos1 = sensorNodes[i].pos;
        const pos2 = sensorNodes[j].pos;
        if (pos1 && pos2) {
          L.polyline([pos1, pos2], {
            color: "rgba(0, 168, 255, 0.4)",
            weight: 1,
          }).addTo(map);
        }
      }
    }
  }

  sensorNodes.forEach((node) => {
    if (!node.pos) return;
    const markerColor = node.type === "sensor" ? "#00a8ff" : "#e84118";
    L.circleMarker(node.pos, {
      radius: 8,
      fillColor: markerColor,
      color: "#ffffff",
      weight: 1.5,
      opacity: 1,
      fillOpacity: 0.9,
    })
      .addTo(map)
      .bindPopup(
        `<strong>Name:</strong> ${node.name}<br><strong>Type:</strong> ${node.type}`
      );
  });

  mapContainer.setAttribute("data-initialized", "true");
}

function createAttentionMap(containerId, sensorData, attentionData) {
  const mainContainer = document.getElementById(containerId);
  if (!mainContainer || mainContainer.getAttribute("data-initialized")) return;

  mainContainer.innerHTML = `
        <div class="attention-controls">
            <label for="target-selector">Select Target Sensor:</label>
            <select id="target-selector"></select>
        </div>
        <div id="attention-map-leaflet" class="attention-map-container"></div>
    `;

  const mapContainer = mainContainer.querySelector("#attention-map-leaflet");
  const selector = mainContainer.querySelector("#target-selector");

  const { sensorNodes } = sensorData;
  const mapCenter = [54.983265, -1.58083];
  const map = L.map(mapContainer).setView(mapCenter, 15);
  let attentionLayerGroup = L.layerGroup().addTo(map);

  L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
    attribution:
      '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
    subdomains: "abcd",
    maxZoom: 20,
  }).addTo(map);

  const nodeLookup = new Map(
    sensorNodes.map((node) => [String(node.id), node])
  );

  sensorNodes.forEach((node) => {
    if (!node.pos) return;
    const isTarget = node.type === "target";
    L.circleMarker(node.pos, {
      radius: isTarget ? 7 : 5,
      fillColor: isTarget ? "#e84118" : "#00a8ff",
      color: "#fff",
      weight: 1.5,
      opacity: 1,
      fillOpacity: isTarget ? 0.9 : 0.7,
    })
      .addTo(map)
      .bindPopup(
        `<strong>ID:</strong> ${node.id}<br><strong>Type:</strong> ${node.type}`
      );
  });

  Object.keys(attentionData).forEach((targetId) => {
    const option = document.createElement("option");
    option.value = targetId;
    const nodeInfo = nodeLookup.get(targetId);
    option.textContent = nodeInfo
      ? `${nodeInfo.name} (ID: ${targetId})`
      : `ID: ${targetId}`;
    selector.appendChild(option);
  });

  // UPDATED: This function now makes lines more visible and adds tooltips.
  function drawAttention(targetId) {
    attentionLayerGroup.clearLayers();
    const attentionList = attentionData[targetId];
    const targetNode = nodeLookup.get(targetId);

    if (!attentionList || !targetNode || !targetNode.pos) return;

    const maxWeight =
      attentionList.length > 0
        ? Math.max(...attentionList.map((a) => a.weight))
        : 0;

    attentionList.forEach((att) => {
      const sourceNode = nodeLookup.get(String(att.source_id));
      if (sourceNode && sourceNode.pos) {
        // Normalize weight for styling (0 to 1)
        const normalizedWeight = maxWeight > 0 ? att.weight / maxWeight : 0;

        const line = L.polyline([sourceNode.pos, targetNode.pos], {
          // Weight is now more pronounced
          weight: 2 + normalizedWeight * 6,
          // Opacity is now more visible
          opacity: 0.5 + normalizedWeight * 0.5,
          color: "#ffd700", // A bright gold/yellow for better visibility
        }).addTo(attentionLayerGroup);

        // ADDED: Bind a tooltip to show the raw weight on hover
        line.bindTooltip(`Attention: ${att.weight.toFixed(4)}`, {
          sticky: true,
          className: "attention-tooltip",
        });
      }
    });
  }

  selector.addEventListener("change", (e) => {
    drawAttention(e.target.value);
  });

  if (selector.options.length > 0) {
    drawAttention(selector.options[0].value);
  }

  mainContainer.setAttribute("data-initialized", "true");
}

/**
 * UPDATED: Creates an interactive line chart with styling and draw order improvements.
 */
function createForecastChart(containerId, forecastData, sensorData) {
  const mainContainer = document.getElementById(containerId);
  if (!mainContainer || mainContainer.getAttribute("data-initialized")) return;

  mainContainer.innerHTML = `
        <div class="forecast-controls">
            <label for="node-selector">Select Sensor Node:</label>
            <select id="node-selector">\n</select>
            <span id="node-type-display"></span>
            <label for="data-slider" style="margin-left: 20px;">Zoom:</label>
            <input type="range" id="data-slider" min="100" value="500">
            <span id="slider-value-display"></span>
        </div>
        <div class="forecast-chart-container">
            <canvas id="forecast-chart-canvas"></canvas>
        </div>
    `;

  const canvas = mainContainer.querySelector("#forecast-chart-canvas");
  const selector = mainContainer.querySelector("#node-selector");
  const typeDisplay = mainContainer.querySelector("#node-type-display");
  const slider = mainContainer.querySelector("#data-slider");
  const sliderValueDisplay = mainContainer.querySelector(
    "#slider-value-display"
  );

  const nodeTimeseriesData = forecastData.nodes;
  const startTimestep = forecastData.start_timestep;

  const nodeLookup = new Map(
    sensorData.sensorNodes.map((node) => [String(node.id), node])
  );
  let chartInstance = null;
  let fullNodeData = null;

  Object.keys(nodeTimeseriesData).forEach((nodeId) => {
    const option = document.createElement("option");
    option.value = nodeId;
    const nodeInfo = nodeLookup.get(nodeId);
    option.textContent = nodeInfo ? nodeInfo.name : `ID: ${nodeId}`;
    selector.appendChild(option);
  });

  function updateChartData() {
    if (!chartInstance || !fullNodeData) return;

    const pointsToShow = parseInt(slider.value, 10);
    sliderValueDisplay.textContent = `${pointsToShow} points`;

    const slicedGt = fullNodeData.ground_truth.slice(-pointsToShow);
    const slicedFc = fullNodeData.forecast.slice(-pointsToShow);
    const slicedLabels = Array.from(
      { length: slicedGt.length },
      (_, i) =>
        startTimestep + fullNodeData.ground_truth.length - pointsToShow + i
    );

    chartInstance.data.labels = slicedLabels;
    chartInstance.data.datasets[0].data = slicedGt;
    chartInstance.data.datasets[1].data = slicedFc;
    chartInstance.update();
  }

  function drawChart(nodeId) {
    const nodeData = nodeTimeseriesData[nodeId];
    const nodeInfo = nodeLookup.get(nodeId);
    if (!nodeData) return;

    fullNodeData = nodeData;
    typeDisplay.textContent = `Type: ${nodeInfo.type}`;
    typeDisplay.style.color =
      nodeInfo.type === "sensor" ? "#00a8ff" : "#e84118";

    slider.max = nodeData.ground_truth.length;
    slider.value = slider.max;
    sliderValueDisplay.textContent = `${slider.value} points`;

    const labels = Array.from(
      { length: nodeData.ground_truth.length },
      (_, i) => i + startTimestep
    );

    const chartConfig = {
      type: "line",
      data: {
        labels: labels,
        datasets: [
          {
            label: "Ground Truth",
            data: nodeData.ground_truth,
            borderColor: "rgba(0, 168, 255, 0.8)",
            backgroundColor: "rgba(0, 168, 255, 0.1)",
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.1,
            order: 2, // Draw this line second (underneath)
          },
          {
            label: "Stitched Forecast (t+1)",
            data: nodeData.forecast,
            borderColor: "rgba(232, 65, 24, 1.0)", // Solid, bright red
            backgroundColor: "transparent",
            borderWidth: 1, // Thicker line
            pointRadius: 0,
            borderDash: [], // Solid line instead of dashed
            order: 1, // Draw this line first
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        aspectRatio: 3,
        animation: false,
        scales: {
          x: {
            type: "linear",
            title: { display: true, text: "Time Step", color: "#FFFFFF" },
            ticks: { color: "#FFFFFF" },
            grid: { color: "rgba(255, 255, 255, 0.2)" },
          },
          y: {
            ticks: { color: "#FFFFFF" },
            grid: { color: "rgba(255, 255, 255, 0.2)" },
            min: -1,
            // max: 100,
          },
        },
        plugins: {
          legend: { labels: { color: "#FFFFFF" } },
          tooltip: { mode: "index", intersect: false },
        },
      },
    };

    if (chartInstance) {
      chartInstance.destroy();
    }
    chartInstance = new Chart(canvas.getContext("2d"), chartConfig);
    updateChartData();
  }

  selector.addEventListener("change", (e) => {
    drawChart(e.target.value);
  });
  slider.addEventListener("input", updateChartData);

  if (selector.options.length > 0) {
    drawChart(selector.options[0].value);
  }

  mainContainer.setAttribute("data-initialized", "true");
}

/**
 * UPDATED: Creates an interactive line chart for the stitched sensor failure simulation.
 * This function now mirrors the structure and features of createForecastChart.
 */
function createFailureSimChart(containerId, failureData, sensorData) {
  const mainContainer = document.getElementById(containerId);
  if (!mainContainer || mainContainer.getAttribute("data-initialized")) return;

  // Set up the HTML structure with a selector and slider
  mainContainer.innerHTML = `
        <div class="failure-controls" style="text-align: center; margin-bottom: 10px;">
            <label for="failure-node-selector-${containerId}">Select Target Node to Simulate Failure:</label>
            <select id="failure-node-selector-${containerId}"></select>
            <label for="failure-data-slider-${containerId}" style="margin-left: 20px;">Zoom:</label>
            <input type="range" id="failure-data-slider-${containerId}" min="100" value="500">
            <span id="failure-slider-value-display-${containerId}"></span>
        </div>
        <div class="failure-chart-container" style="height: calc(100% - 40px);"><canvas id="failure-chart-canvas-${containerId}"></canvas></div>
    `;

  const canvas = mainContainer.querySelector(
    `#failure-chart-canvas-${containerId}`
  );
  const selector = mainContainer.querySelector(
    `#failure-node-selector-${containerId}`
  );
  const slider = mainContainer.querySelector(
    `#failure-data-slider-${containerId}`
  );
  const sliderValueDisplay = mainContainer.querySelector(
    `#failure-slider-value-display-${containerId}`
  );

  const nodeTimeseriesData = failureData.nodes;
  const startTimestep = failureData.start_timestep;
  const nodeLookup = new Map(
    sensorData.sensorNodes.map((node) => [String(node.id), node])
  );
  let chartInstance = null;
  let fullNodeData = null;

  // Populate the selector with available nodes from the failure data
  Object.keys(nodeTimeseriesData).forEach((nodeId) => {
    const option = document.createElement("option");
    option.value = nodeId;
    const nodeInfo = nodeLookup.get(nodeId);
    option.textContent = nodeInfo ? nodeInfo.name : `ID: ${nodeId}`;
    selector.appendChild(option);
  });

  // Function to update the chart based on the slider
  function updateChartData() {
    if (!chartInstance || !fullNodeData) return;
    const pointsToShow = parseInt(slider.value, 10);
    sliderValueDisplay.textContent = `${pointsToShow} points`;

    // Slice all three datasets
    const slicedGt = fullNodeData.ground_truth.slice(-pointsToShow);
    const slicedNormal = fullNodeData.prediction_normal.slice(-pointsToShow);
    const slicedFailure = fullNodeData.prediction_failure.slice(-pointsToShow);

    const slicedLabels = Array.from(
      { length: slicedGt.length },
      (_, i) =>
        startTimestep + fullNodeData.ground_truth.length - pointsToShow + i
    );

    chartInstance.data.labels = slicedLabels;
    chartInstance.data.datasets[0].data = slicedGt;
    chartInstance.data.datasets[1].data = slicedNormal;
    chartInstance.data.datasets[2].data = slicedFailure;
    chartInstance.update("none"); // Use 'none' for no animation to keep it snappy
  }

  // Function to draw or redraw the entire chart for a new node
  function drawChart(nodeId) {
    const nodeData = nodeTimeseriesData[nodeId];
    if (!nodeData) return;

    fullNodeData = nodeData;
    slider.max = nodeData.ground_truth.length;
    slider.value = slider.max; // Default to showing all data

    const labels = Array.from(
      { length: nodeData.ground_truth.length },
      (_, i) => i + startTimestep
    );

    const chartConfig = {
      type: "line",
      data: {
        labels: labels,
        datasets: [
          {
            label: "Ground Truth",
            data: nodeData.ground_truth,
            borderColor: "rgba(0, 168, 255, 0.9)", // Blue
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.1,
            order: 3, // Draw last (on top)
          },
          {
            label: "Prediction (Original)",
            data: nodeData.prediction_normal,
            borderColor: "rgba(232, 65, 24, 1.0)", // Red
            borderWidth: 1.5,
            pointRadius: 0,
            borderDash: [5, 5], // Dashed line
            tension: 0.1,
            order: 2,
          },
          {
            label: "Prediction (Node Failure)",
            data: nodeData.prediction_failure,
            borderColor: "rgba(76, 209, 55, 0.9)", // Green
            borderWidth: 1.5,
            pointRadius: 0,
            borderDash: [3, 3], // Dashed line
            tension: 0.1,
            order: 1, // Draw first (on bottom)
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        scales: {
          x: {
            type: "linear",
            title: { display: true, text: "Time Step", color: "#FFFFFF" },
            ticks: { color: "#FFFFFF" },
            grid: { color: "rgba(255, 255, 255, 0.2)" },
          },
          y: {
            ticks: { color: "#FFFFFF" },
            grid: { color: "rgba(255, 255, 255, 0.2)" },
            min: -1,
          },
        },
        plugins: {
          legend: { position: "top", labels: { color: "#FFFFFF" } },
          tooltip: { mode: "index", intersect: false },
        },
      },
    };

    if (chartInstance) {
      chartInstance.destroy();
    }
    chartInstance = new Chart(canvas.getContext("2d"), chartConfig);
    updateChartData(); // Initial call to set slider value text and points
  }

  // Attach event listeners
  selector.addEventListener("change", (e) => drawChart(e.target.value));
  slider.addEventListener("input", updateChartData);

  // Initial drawing
  if (selector.options.length > 0) {
    drawChart(selector.options[0].value);
  }

  mainContainer.setAttribute("data-initialized", "true");
}

// --- Main Dispatcher Function ---
async function processVisualizationSlide(slideElement) {
  // Fetch all necessary data in parallel
  const [sData, aData, fData, failData] = await Promise.all([
    getSensorData(),
    getAttentionData(),
    getForecastData(),
    getFailureData(),
  ]);

  const vizElements = slideElement.querySelectorAll("[data-viz]");

  vizElements.forEach((element) => {
    const vizType = element.getAttribute("data-viz");
    const elementId = element.id;

    if (!elementId) {
      console.error("Visualization container is missing a unique ID.", element);
      return;
    }

    // Initialize the correct visualization based on the data-viz attribute
    switch (vizType) {
      case "map":
        if (sData) createSensorMap(elementId, sData);
        break;
      case "bar-chart":
        if (sData) createBarChart(elementId, sData);
        break;
      case "flowchart":
        createFlowchart(elementId);
        break;
      case "connected-graph":
        if (sData) createConnectedGraph(elementId, sData);
        break;
      case "attention-map":
        if (sData && aData) createAttentionMap(elementId, sData, aData);
        break;
      case "forecast-chart":
        if (fData && sData) createForecastChart(elementId, fData, sData);
        break;
      case "failure-simulation-chart":
        // This now calls the updated function with the stitched data
        if (failData && sData)
          createFailureSimChart(elementId, failData, sData);
        break;
      default:
        console.warn(`Unknown visualization type: ${vizType}`);
    }
  });
}
